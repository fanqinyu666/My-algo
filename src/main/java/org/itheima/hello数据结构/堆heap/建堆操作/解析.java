package org.itheima.hello数据结构.堆heap.建堆操作;

public class 解析 { }
//在某些情况下，我们希望使用一个列表的所有元素来构建一个堆
// ，这个过程被称为“建堆操作”。

//我们首先创建一个空堆，然后遍历列表，依次对每个元素执行“入堆操作”，即先将元素
// 添加至堆的尾部，再对该元素执行“从底至顶”堆化。/每当一个元素入堆，堆的长度
//就加一。由于节点是从顶到底依次被添加进二叉树的，因此堆是“自上而下”构建的。
// 设元素数量为 n 每个元素的入堆操作使用 O（log n）
// 时间，因此该建堆方法的时间复杂度为 O(nlog n)
// 。



//实际上，我们可以实现一种更为高效的建堆方法，共分为两步。
//
//将列表所有元素原封不动地添加到堆中，此时堆的性质尚未得到满足。
//倒序遍历堆（层序遍历的倒序），依次对每个非叶节点执行“从顶至底堆化”。
//每当堆化一个节点后，以该节点为根节点的子树就形成一个合法的子堆。而由于是倒序遍历，因此堆是“自下而上”构建的。
//
//之所以选择倒序遍历，是因为这样能够保证当前节点之下的子树已经是合法的子堆，这样堆化当前节点才是有效的。
//
//值得说明的是，由于叶节点没有子节点，因此它们天然就是合法的子堆，无须堆化。如以下代码所示，最后一个非叶节点是最后一个节点
// 的父节点，我们从它开始倒序遍历并执行堆化：


//假设完全二叉树的节点数量为n
// ，则叶节点数量为 (n+1)/2
// ，其中/
// 为向下整除。因此需要堆化的节点数量为(n-1)/2
// 。在从顶至底堆化的过程中，每个节点最多堆化到
// 叶节点，因此最大迭代次数为二叉树高度


//O(n)





